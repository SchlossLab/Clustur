---
title: "Using clustur"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using-clustur}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Opticluster)
library(Matrix)
```

# Starting Up

clustur was developed similarly to the traditional c++ implementation, however there are a few differences to note. In order to clustur your data, we are requiring users to build out there own sparse matrix (we also support phylip files) and count table in R. Once these objects are built out you can call the cluster function. We currently support 5 cluster functions from mothur: furthest, nearest, weighted, average, and opticluster. Each of these clusters will produce data comparable to mothur efficiently. Below I will show you how to create your sparse matrix and count table. Do not worry if you do not have a count table, as long as you have the data, we can create a blank count table. The blank count table will still output cluster results, but your abundance information will only describe the frequency.


## To Begin

Lets create the sparse matrix: The easiest way to create a sparse matrix, is to use the "dgTMatrix" class in the Matrix library.

```{r R.options=list(max.print=10)}
# Lets create some data
i_values <- as.integer(1:100)
j_values <- as.integer(sample(1:100, 100, T))
x_values <- as.numeric(runif(100, 0, 1))
s_matrix <- new("dgTMatrix",
          i = i_values,
          j = j_values,x=x_values, Dim=102:103)
s_matrix
```

Now we have a matrix that is represented as a tripliclate. In this example we do not have any names that correspond to the indexes, so we will use the index numbers as names and create a count table.


```{r}
# We are using random numbers between one and 100, so that will be our first column
# We will also give each sequence an abundance of 1
count_table <- data.frame(sequence=as.character(i_values), total=rep(1,times=100))

```


There are a few ways to cluster the data, but lets start with using the opticluster method:

```{r}
cluster_results <- opti_cluster(cutoff=0.2, count_table = count_table, sparse_matrix=s_matrix)
```

opticluster outputs a list of 4 dataframes. The clustering data, the abundance data, the cluster metrics, and additional clustering metrics. The cluster looks like this:

```{r R.options=list(max.print=15)}
cluster_results$cluster
```

otu represent the clusters, the label represents the highest cutoff, and the bin represents the sequences inside of each cluster.

### Count table

A count table is required for every clustering method. The count file is used to calculate the group abundance of each seqeunces. This is how we determine how abundant and create a shared file (additional information from the Mothur documentation [Shared file](https://mothur.org/wiki/shared_file/)). We created one earlier, but lets revisit the topic.

Lets take a look at the count_table we created earlier

```{r R.options=list(max.print=15)}
count_table
```

This count table contains two headers, sequence and total. The sequence header contains the names of the sequences and the total is its total abundance. In our case we do not have abundance based on groups in this count table. But there are many different count tables that do. 

We were able to create this count table because we had a ***unique*** count of sequences (1-100), and we were able to use those to generate the table. ***If a sequence in your distance table is not present, it will return as a 0 and may disrupt your results. ***



## Column Distance file

Just like in mothur where you can input column files, we can do the same thing in clustur. By using the conditional argument, column_path, we can use it as input. You also have to create a count table. In this case, we just need to ensure that every name is represented inside the table. Since we do not have any abundance values, we just give each sequence an abundance of 0.

Additional information:[column distance file](https://mothur.org/wiki/column-formatted_distance_matrix/)

To start let me show you a typically count table:

```{r R.options=list(max.print=15)}
df_count <- read.delim(example_path("amazon1.count_table"))
df_count
# names(df_count) <- c("Representative_Sequence", "total")
# count <- df_count[,1:2]
# unique_names <-  unique(count$Representative_Sequence) 
# abund <- rep(1, times=length(unique_names))
# count <- data.frame(Representative_Sequence=unique_names, total=abund)
# names(count)[2] <- "total"

```

A normal count table consists of the names of each sequence, the total amount of abundance (the total), and groups. This count table does not display any group information, however, it is common to include the abundance per group when dealing with numerous sequences. For the sake of this demonstration, we will not include any group information. Therefore this format is similar to the name file in Mothur. Keep in mind, inside the code, when we detect that no groups are present, we will add a no-group tag for processing. 


Using the column distance file and a count table we can cluster!
```{r R.options=list(max.print=15)}


amazon_data_column <- opti_cluster(column_path=example_path("96_sq_column_amazon.dist"),
                      count_table = df_count, cutoff = 0.2)
amazon_data_column$cluster$bins
```


## Phylip distance file

Just like Mothur we allow the use of column distance matrices and phylip distance files.

```{R R.options=list(max.print=15)}

amazon_data_phylip <- opti_cluster(phylip_path=example_path("98_sq_phylip_amazon.dist"),
                      count_table = df_count, cutoff = 0.2)
amazon_data_phylip$clusters$bin 
```


## Other clustering methods

For most of the examples we have been using the opti-clust method but we can also use furthest, nearest, average, and weighted.
Furthest:

```{R R.options=list(max.print=15)}

amazon_data_phylip <- cluster(phylip_path=example_path("98_sq_phylip_amazon.dist"),
                      count_table = df_count, method="furthest", cutoff = 0.2)
amazon_data_phylip$cluster$bins
```

Nearest:

```{R R.options=list(max.print=15)}

amazon_data_phylip <- cluster(phylip_path=example_path("98_sq_phylip_amazon.dist"),
                      count_table = df_count, method="nearest", cutoff = 0.2)
amazon_data_phylip$cluster$bins
```

Average:

```{R R.options=list(max.print=15)}

amazon_data_phylip <- cluster(phylip_path=example_path("98_sq_phylip_amazon.dist"),
                      count_table = df_count, method="average", cutoff = 0.2)
amazon_data_phylip$cluster$bins
```

Weighted:

```{R R.options=list(max.print=15)}

amazon_data_phylip <- cluster(phylip_path=example_path("98_sq_phylip_amazon.dist"),
                      count_table = df_count, method="weighted", cutoff = 0.2)
amazon_data_phylip$cluster$bins
```
