---
title: "Using clustur"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using-clustur}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Opticluster)
library(Matrix)
```

# mothur
mothur is an open-sourced software used for the analysis of ecological data. It has a strong presence in the use of analyzing 16S rRNA gene sequences.
mothur itself has a plethora of features, such as, clustering based on genetic similarity, sequence alignment, taxomic assignment, alpha and beta diversity,
and phylotype analysis. There have been numerous publications using this software by individuals and intuitions alike. We plan to take advantage of the power of
mothur, and isolate the clustering feature. We believe this will allow scientist to work with a familiar tool and give rise for the creation of more pipelines
utilizing this package.


# clustur
clustur was developed for two main reasons: to allow developers to easily create pipelines with mothur code in R, and to give users a powerful
clustering algorithm from mothur without having to download it. Because mothur is built using rcpp, it benefits from the speed of c++
and the usability of R. Additionally, since clustur will be open source, developers can modify are package as needed. This will not only
help us continue to create high quality packages, but will allow everyone to take advantage of the foundation that is already built.

# Starting Up
clustur was developed similarly to the traditional c++ implementation, however there are a few differences to note. In order to clustur
your data, we are requiring users to build out there own sparse matrix (we also support phylip files) and count table in R. Once these
objects are built out you can call the cluster function. We currently support 5 cluster functions from mothur: furthest, nearest,
weighted, average, and opticlust. Each of these clusters will produce data comparable to mothur efficiently. Below I will show you
how to create your sparse matrix and count table. Do not worry if you do not have a count table, as long as you have the data,
we can create a blank count table. The blank count table will still output cluster results, but your abundance information will
only describe the frequency.

## To Begin
Lets create the sparse matrix:
The easiest way to create a sparse matrix, is to use the "dgTMatrix" class in the Matrix library.
```{r R.options=list(max.print=10)}
# Lets create some data
i_values <- as.integer(1:100)
j_values <- as.integer(sample(1:100, 100, T))
x_values <- as.numeric(runif(100, 0, 1))
s_matrix <- new("dgTMatrix",
          i = i_values,
          j = j_values,x=x_values, Dim=102:103)
s_matrix
```

Now we have a matrix that is represented as a tripliclate. In this example we do not have any names that correspond to the indexes, so we will use the index numbers as names and create a count table.

```{r}
# We are using random numbers between one and 100, so that will be our first column
# We will also give each sequence an abundance of 1
count_table <- data.frame(sequence=as.character(i_values), total=rep(1,times=100))

```

There are a few ways to cluster the data, but lets start with using the opticluster method:

```{r}
cluster_results <- opti_cluster(cutoff=0.2, count_table = count_table, sparse_matrix=s_matrix)
```

opticluster outputs a list of 4 dataframes. The clustering data, the abundance data, the cluster metrics, and additional clustering metrics. The cluster looks like this:

```{r R.options=list(max.print=10)}
cluster_results$cluster
```

otu represent the clusters, the label represents the highest cutoff, and the bin represents the sequences inside of each cluster.


## Column Distance file
Just like in mothur where you can input column files, we can do the same thing in clustur. By using the conditional argument, column_path, we can use it
as input. You also have to create a count table. In this case, we just need to ensure that every name is represented inside the table. Since we do not have any abundance values, we just give each sequence an abundance of 0.

```{r}
df_count <- read.delim("/Users/grejoh/Documents/mothur/mothur/AmazonData/amazon1.count_table")
df <- read.delim("/Users/grejoh/Documents/mothur/mothur/AmazonData/96_sq_column_amazon.dist", header = FALSE)
names(df) <- c("Representative_Sequence", "total")
count <- df[,1:2]
unique_names <-  unique(count$Representative_Sequence) 
abund <- rep(1, times=length(unique_names))
count <- data.frame(Representative_Sequence=unique_names, total=abund)
names(count)[2] <- "total"
amazon_data_column_1 <- opti_cluster(column_path="/Users/grejoh/Documents/mothur/mothur/AmazonData/96_sq_column_amazon.dist", 
                      count_table = df_count, cutoff = 0.2)
# answer1 <- readr::read_delim("/Users/grejoh/Documents/mothur/mothur/AmazonData/96_sq_column_amazon.opti_mcc.list",delim="\t")
# tidy_answer1 <- reshape2::melt(answer, id=c("label","numOtus"), variable.names="OTU", value.name="clusters")
```






